# 1. 게임의 구성 (2023.01.29)
[Home](/README.md)

[이전 글](/Notes/Prometheus/PrometheusEngineDevelopment.md)

사람마다 게임 개발에 빠지게 된 이유는 다양하다. 게임 그래픽이 멋있어서, 똑똑한 인공지능으로 더 재미있는 게임을 만드려고, 내 손으로 가상의 환경을 만드는 게 재미있어서. 그렇게 자연스럽게 게임 개발에 대한 공부를 시작하고, 많은 사람들은 GameMaker, Unity, Unreal Engine 등과 같은 툴을 알게 된다.

하지만 좀 더 개발자스럽게 접근을 한다면, 실제 게임을 개발하려면 보통 DirectX 샘플<sup>[D3D11](https://github.com/walbourn/directx-sdk-samples), [D3D12](https://github.com/microsoft/DirectX-Graphics-Samples)</sup>을 보면서 시작하게 된다. 그렇게 간단하게 구현하여 무언가 화면에 보이는 순간 뭔가 만들었다는 기분이 들을 것이다.

그러나 실제 게임 개발은 이제부터 시작한 것이다. 게임은 그래픽만 있는 것이 아니기 때문이다.

## 1.1. 게임의 구조

참조: Game Coding Complete 4th Edition. Mike Schaffry. 2011.

크게 세 가지로 나뉨:

1. 어플리케이션 계층
2. 게임 로직 계층
3. 게임 뷰 계층

어플리케이션 계층에서 하드웨어와 OS를 처리하고, 게임 로직 계층에서 게임의 상태와 시간에 따른 변화를 관리하고, 게임 뷰 계층은 게임의 상태를 실제 유저에게 그래픽이나 사운드와 같은 감각 정보로 출력해준다.

어플리케이션 계층이 하드웨어와 OS를 처리한다는 뜻은, 개발할 게임의 플랫폼이 Windows든, iOS든, Android든, Xbox Series X/S든, PS5든, Nintendo Switch든, 이 모든 플랫폼에 대응하는 코드는 어플리케이션 계층 밖에 없다는 것이다. 최대한 상위 계층에는 영향을 주지 않도록 여기서 최대한 다 처리해야 한다. 여기서 마우스와 같은 실제 하드웨어를 처리하고, 네트워킹이나 스레드와 같은 운영체제와 관련된 일들을 처리하고, 게임의 초기화 및 종료를 처리한다.

게임 로직 계층은 즉 실제 게임을 의미한다. 어느 플랫폼에서 도는지, 어떻게 화면에 렌더링이 되는지와 무관하게 게임의 세계 자체를 구현한다고 보면 된다. 대표적으로는 게임 안의 물체들이 움직이고 상호작용하는 물리 시스템 등이 있을 것이다.

마지막으로는 게임 뷰 계층이 있다. 여기서 로직 계층이 갖는 상태를 유저에게 출력해주고, 유저의 입력을 게임 커맨드로 바꾸어 게임 로직에게 전달해준다. 대표적인 예시로는 플레이어의 뷰가 있는데, 여기서는 화면에 체력이나 플레이어 모델과 같은 게임의 상태를 그려주고, 스피커나 헤드폰에 오디오를 출력해주고, 유저의 입력을 받아주는 것이다. 또다른 뷰로는 NPC와 같이 인공지능이 있는 AI 에이전트 뷰가 있을 것이고, 네트워크 상으로 우리와 같이 게임을 하고 있는 다른 플레이어의 뷰 등이 있을 것이다. 이들은 전부 같은 게임 로직 계층에서 동일한 상태를 받아오지만 전부 뷰만 다른 것이다.

## 1.2. 게임의 구조를 적용한 예시

예를 들어 레이싱 게임을 개발하자고 하자. 레이싱 게임의 게임 로직은 보통 자동차와 트랙에 대한 데이터들을 갖고 있을 것이다. 차의 경우 차에 하중이 어떻게 분산되어 있는지, 엔진의 성능이 어떤지, 타이어의 성능은 또 어떤지, 연비는 어떤지 등등에 대한 정보가 있을 것이고, 트랙의 경우에는 트랙의 생김새, 트랙 표면의 성질 등이 있을 것이다. 또한 가속도와 운전 조작이 주어졌을 때, 트랙에 어떻게 반응 혹은 충돌하는지, 혹은 유저의 입력에 어떻게 반응하는지 대한 물리 시스템 등도 있을 것이다.

게임 로직은 딱 운전 조작, 가속도, 브레이크, 긴급 브레이크 등과 같은 입력만 받으면 된다. 물론 차에 총 같은 게 달려 있어서 방아쇠 입력도 추가할 수도 있을 것이다.

게임 로직의 출력은 결국 이러한 상태의 변화와 발생하는 이벤트들이다. 여기서 상태라는 것은 차의 위치, 방향, 차체에 따른 휠의 위치와 방향, 차의 체력 등등이 있을 것이다. 이벤트로는 충돌 이벤트 등이 있을 것이다. 이러한 정보와 이벤트들은 최종적으로 게임 뷰에 전달된다.

게임 뷰는 결국 이 게임의 상태를 유저에게 보여주는 임무를 담당한다. 즉, 플레이어의 시점에서 화면이 어떻게 보이는지, 무엇이 들리는지 등등을 출력해주는 것이다.

한 번 플레이어가 Xbox의 긴급 브레이크 버튼을 눌렀다고 가정하자. 이러면 플레이어의 시점에서는 이걸 긴급 브레이크를 하라는 의도로 해석하여 이러한 입력을 게임 로직에게 전달하게 된다. 이러면 게임 로직은 플레이어의 차의 긴급 브레이크를 작동 시키라는 상태로 변화할 것이고, 이를 게임 뷰에 전달할 것이다. 게임 뷰는 이에 따라 화면에 브레이크를 눌렀다는 시각 정보나 청각 정보를 보여줄 것이다.

NPC의 시점은 조금 다를 것이다. 결국 받는 게임의 상태는 플레이어와는 동일하지만 이걸 보고 앞에 브레이크를 밟은 차를 피하라는 것으로 해석하여 휠을 오른쪽으로 꺾으라는 명령을 게임 로직에 입력으로 줄 수도 있다.

## 1.3. 어플리케이션 계층

게임 어플리케이션 계층은 또 여러 하위 계층으로 나뉜다:

* 장치
  * 입력
  * 파일
  * 메모리
  * 시간
* 운영체제
  * 언어
  * DLL
  * 병렬 처리
  * 네트워크
* 게임 수명
  * 핵심 라이브러리
  * 메인 루프
  * 초기화 & 종료

### 1.3.1. 입력

키보드, 마우스, 게임패드, 조이스틱, 휠, 카메라, 가속도 센서, GPS 등등, 입력 장치는 여러 가지다. 이러한 입력 장치에 대한 정보를 읽어오는 것은 사실상 운영체제와 장치 드라이버가 없으면 불가능하다. 게임에서는 이러한 입력 장치의 정보를 게임 명령어들로 바꿔주어야 한다. 롤에서 R을 누르면 궁이라는 명령어로 바꿔줘야 하듯이 말이다. 근데 이게 게임 명령어는 하나인데, 입력 장치는 여러 가지가 될 수 있다. 앞으로 가는 명령어는 키보드에서는 W, 게임패드에서는 왼쪽 조이스틱에서 앞으로 기운 정도일 것이다.

### 1.3.2. 파일 시스템과 리소스 캐싱

게임에서 사용하는 리소스들이 워낙 많다보니 파일 관리의 필요성이 있을 수 밖에 없고, 이걸 열고 닫는 기능도 필요하다. GTA와 같은 스케일이 매우 큰 게임의 경우 그 많은 리소스들을 효율적으로 사용할 수 있도록 캐싱을 해줘야할 것이다. 딱 봐도 자주 사용할 것 같은 리소스들은 미리 메모리에 올려 놓고 그때 그때 가져와서 사용하고, 그렇지 않은 리소스들은 하드 디스크에서 읽어오지 않는 것이다.

### 1.3.3. 메모리 관리

게임에서 매우 중요한 분야이다. GameMaker Studio나 Unity, Unreal Engine과 같은 상용 게임 엔진으로 게임을 개발하는 이들에게는 잘 모르겠지만, 메모리 관리 하나로 게임의 성능이 천지차이가 난다. 이미 C/C++을 배워서 알고 있는 분들에게는 놀라운 이야기겠지만, 기본 C/C++에서 제공하는 동적 메모리 할당 함수는 매우