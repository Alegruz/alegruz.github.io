---
layout: post
title:  "그래픽스 공부: Fundamentals of Computer Graphics. 03. 래스터 이미지"
date:   2025-01-19 00:00:00 +0000
categories: graphics korean
---

일반적으로 컴퓨터 그래픽스는 모니터와 같이 각각의 픽셀로 이루어져 있다. 우리가 유튜브로 멋있는 바다 영상을 볼 땐 모니터 위의 한 화소가 각각 특정 색을 띠고 있는 것이다. 실제 바다는 한 픽셀 단위로 색을 가지는 것이 아니고 연속된 색을 띠고 있다. 하지만 이것을 디지털화하여 처리하려면 결국 데이터를 이산적으로 저장해야 한다. 이것을 *래스터 디스플레이raster display*라 부른다. 래스터 디스플레이란 이미지를 *픽셀pixel*이라 불리는 사각형의 배열로 보여주는 것을 의미한다. 즉, *래스터 이미지raster image*란 단순히 각 픽셀 대한 *픽셀값pixel value*을 원소로 갖는 2D 배열을 의미한다. 결국 출력 장치라는 것은 실제 현실을 근사해서 보여주는 것이고, 이 출력 장치 위에 출력되는 이미지가 래스터 이미지다. 유튜브 영상이라는 래스터 이미지를 핸드폰이라는 출력 장치로 볼 수도 있고, 모니터로도 볼 수도 있듯이, 래스터 이미지는 *장치와 독립적인device-independent* 개념이다.

래스터 이미지처럼 데이터를 이산적으로 저장하는 방법 말고는 음성을 푸리에 변환으로 표현하듯이 영상을 수학적으로 암시적으로 표현하는 *벡터 이미지vector image*가 있다. 벡터 이미지는 모양, 즉 어떤 선이나 곡선으로 둘러 싸인 색에 대한 설명을 픽셀과 무관하게 표현하는 방법이다. 디스플레이할 때 필요한 각 픽셀에 대응하는 값이 아니라, 이미지를 그릴 때 필요한 *연산instruction*을 저장하는 방법이다. 자연스럽게 벡터 이미지가 갖는 가장 큰 장점은 디스플레이의 *화질과 독립적resolution-indepdendent*하다는 것이다. 단점이라면 결국 디스플레이 자체는 래스터 디스플레이이므로 벡터 이미지도 최종적으로는 *래스터화rasterize*를 해야 한다. 벡터 이미지는 주로 글자, 다이어그램, 기계 제도처럼 쉐이딩은 별로 안 중요하지만 명확하게 보여야하고, 정밀도가 중요한 분야에 사용한다.

## 3.1. 래스터 장치

* 출력
  * 디스플레이
    * LCD/LED
  * 인쇄 출력
    * 프린터 등
* 입력
  * 디지털 카메라, 스캐너 등

### 3.1.1. 디스플레이

LED, LCD 등 픽셀로 구성된 것들이다. 이때 한 픽셀은 빨간색, 초록색, 파란색으로 구성된 세 개의 *부분 픽셀subpixel*로 구성된다. 이 픽셀의 구성에 따라 *화질resolution*이 결정된다.

### 3.1.2. 인쇄 출력

결국 프린터도 래스터하게 한 픽셀마다 잉크를 찍어주는 것이다.

### 3.1.3. 입력 장치

디지털 카메라 같은 것. 아날로그 카메라는 필름에 바로 빛을 쏘는 거라 래스터 이미지가 아닌 연속된 아날로그 이미지다.

## 3.2. 이미지, 픽셀 및 기하

이미지는 보통 빛 에너지의 2차원 분포로 표현한다. 모니터에서 발산하는 빛은 디스플레이 표면의 한 위치에 대한 함수로 표현한다. 카메라의 이미지 센서로 들어오는 한 빛은 센서 표면의 한 위치에 대한 함수로 표현한다. 빛이 반사되는 정도(빛을 흡수하는 정도의 반대)를 의미하는 *반사도reflectance*는 예를 들어 종이 위의 한 위치에 대한 함수로 표현한다.

이미지는 결국 2차원이니까 대한 함수를 다음과 같이 일반화할 수 있다:

I(x, y): R &rarr; V

여기서 R ⊂ 	&#8477;<sup>2</sup>은 사각형의 영역을 의미하고, V는 픽셀값의 공역을 의미한다.

픽셀은 실제 보이는 영역을 크기를 갖는 사각형으로 퉁치는 것이기 때문에, 이 사각형이 차지하는 범위의 모든 색의 평균값을 픽셀값으로 갖는다. 이걸 이미지의 *점표본point sample*이라 부른다. 즉, "픽셀의 값이 x다"라고 하는 것은 결국 "이미지의 이 영역에 해당하는 값은 x다"라고 하는 것이다.

이미지는 2차원 배열이라고 했기에 i(열)와 j(행)와 같은 값으로 인덱싱을 할 수 있다.

### 3.2.1. 픽셀값

일반적으로 빛의 세기에는 딱히 범위가 없지만, 결국 이 빛을 내는 모니터에는 한계가 있기 때문에 일반적으로 단순성을 위해 빛의 세기는 [0, 1]의 범위를 갖는다고 규정한다. 이처럼 값을 부동소수점으로 저장하는 방식을 *높은 동적 범위high dynamic range*(HDR)라 부르고, 정수로 저장하는 방식을 *낮은 동적 범위low dynamic range*(LDR)라 부른다. 이때 이 범위를 얼마나 잘게 나누느냐에 따라 이미지의 정밀도가 정해진다. 예를 들어 하얀색 혹은 검은색만 나타내고 싶다면 한 픽셀의 범위는 0과 1만 갖는 집합일 것이다. 만약 회색까지 표현해주려면 2 개 이상의 원소가 필요할 것이다. 예를 들어 {0, 1/255, 2/255, &hellip;, 255/255}로 256 개의 원소를 갖는 것이다. 일반적으로 RGB 값은 각 원소가 위의 방식처럼 256 개의 색을 갖는다. 이를 8 bit 색이라고 한다. 만약 이 나누는 개수를 줄이면 사진에 *왜곡artifact*이 발생한다. 대표적으로는 더욱 더 밝아야 하는데 덜 밝게 저장된다거나, 더 어두워야 하는데 덜 어둡게 저장되는 것처럼 상한과 하한에 영향을 주는 *클리핑clipping* 현상이 있다. 다른 현상으로는 정밀도가 낮아지면서 이미지 상에서 픽셀 간에 색이나 세기가 눈에 띄게 이격이 발생하는 *양자화quantization* 왜곡 혹은 *밴딩banding* 현상이 있다.

### 3.2.2. 모니터 세기와 감마

모니터 자체도 어쨋든 표면이 있을 것이고, 이 표면은 물리적 성질에 따라 빛을 반사하고 있다. 즉, 빛의 세기가 0이 아닌 것이다.

모니터는 색을 선형적으로 출력하지 않는다. 만약 우리가 모니터에 색의 세기를 0.0, 0.5, 1.0로 줬더라도 모니터는 이걸 0.0, 0.25, 1.0으로 자기 마음대로 변형해서 출력할 수도 있다는 것이다. 이런 비선형성을 모니터에서는 &gamma;(감마)라는 값에 의해 결정된다. 이 값의 의미는 다음과 같다:

출력 세기 = (최대 세기)a<sup>&gamma;</sup>

이때 a는 [0, 1] 범위를 갖는 입력 세기다. 이때 &gamma;로 디스플레이의 비선형성을 나타내는 것은 그저 근사일 뿐이다.

감마값을 구해야 실제 의도대로 출력도 0.0, 0.5, 1.0이 나오도록 *감마 보정gamma correction*을 해줄 수 있다.

a' = a<sup>1 / &gamma;</sup>

## 3.3. RGB 색

RGB 색공간의 기본적인 아이디어는 세 개의 주요primary 빛인 빨간색 초록색 파란색을 섞어서 색을 출력한다는 것이다. 이때 빛은 덧셈을 통해 섞는다. 빨간색 + 초록색 = 노란색 이런 식이다.

RGB는 세 요소를 갖기 때문에 이 세 요소에 각각 0 혹은 1이라는 값을 부여하고, 그렇게 해서 얻은 여섯 개의 벡터들을 정육면체의 꼭지점으로 삼아 *RGB 색 정육면체RGB color cube*를 만들 수 있다.

RGB로 구성된 시스템에서는 각 주요 색마다 256 개의 색을 가지기 때문에 "24 비트 색"을 갖는다고 할 수 있다.

## 3.4. 알파 합성

보통 이미지에는 여러 가지가 존재한다. 예를 들면 원경이 있고 근경 두 가지가 있을 수 있다. 이미지를 최종적으로 만드려면 원경을 그리고 그 위에 근경을 그려주면 된다. 이런 과정을 *합성composition*이라 부른다. 이때 근경이 원경을 완전하게 가릴 수도 있고, 아닐 수도 있다. 예를 들어 근경에 셀로판지처럼 반투명할 경우도 있고, 유리처럼 투명한 경우도 있을 것이다.

근경을 원경 위에 그릴 때 가장 중요한 건 *픽셀 포함율pixel coverage*이다. 같은 픽셀에서 근경이 원경을 얼마나 가리느냐를 의미하는 것이다. 이걸 보통 &alpha;라는 분수로 표현한다. 해당 픽셀에서 근경이 c<sub>f</sub>라는 색을 갖고, 배경이 c<sub>b</sub>라는 색을 갖는다면, 최종 픽셀값 c는 다음과 같다:

c = &alpha;c<sub>f</sub> + (1 - &alpha;)c<sub>b</sub>

근경이 만약 불투명하다면, &alpha;는 근경이 픽셀을 차지하는 정도를 의미하게 된다. 근경이 만약 반투명 혹은 투명하다면 근경이 원경의 색을 (1 - &alpha;)만큼 막고, 자신의 색을 &alpha;으로 막은 색을 대체한다는 의미다.

&alpha; 값은 따로 흑백 이미지로 저장할 수 있다. 이 이미지를 *알파 마스크alpha mask* 혹은 *투명도 마스크transparency mask*라 부른다. 따로 이미지로 저장하지 않고 RGB의 네번째 요소로 추가하여 RGBA로 만들 수도 있다. 이때 새로 추가된 A를 *알파 채널alpha channel*이라 부른다.

### 3.4.1. 이미지 저장

디지털 데이터가 늘 그렇듯 용량 줄이기 싸움이지 않는가? 이미지도 마찬가지다. 즉 압축이 등장한다. 압축은 당연하지만 *무손실lossless*과 *손실lossy* 압축이 있다.